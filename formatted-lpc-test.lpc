#pragma strong_types
#pragma save_types
#pragma warn_deprecated
#pragma combine_strings
#pragma verbose_errors

/*
 * LDMUD Language Feature Test File
 * 
 * This file demonstrates all LDMUD/LPC language features, data types,
 * operators, and syntax patterns for testing the formatter.
 * 
 * Author: Test Suite
 * Driver: LDMUD 3.6+
 */

// ============================================================================
// INCLUDES AND DEFINES
// ============================================================================

#include <sys/driver_hook.h>
#include <sys/functionlist.h>
#include <sys/lpctypes.h>
#include <sys/objectinfo.h>
#include <sys/rtlimits.h>
#include <sys/trace.h>

#define MAX_VALUE 100
#define MIN_VALUE 0
#define DEFAULT_NAME "test"
#define VERSION "1.0.0"

#ifdef __COMPAT_MODE__
#define IS_COMPAT 1
#else
#define IS_COMPAT 0
#endif

#if defined(__TLS__)
#define HAS_TLS 1
#endif

// ============================================================================
// DATA TYPES - All LDMUD types
// ============================================================================

// Basic types
int integer_var = 42;
float float_var = 3.14159;
string string_var = "Hello LDMUD";
object object_var = this_object();
mixed mixed_var = 0;
void void_function();

// Compound types
int *int_array = ({ 1, 2, 3, 4, 5 });
string *string_array = ({ "one", "two", "three" });
object *object_array = ({ });
mixed *mixed_array = ({ 1, "two", 3.0, this_object() });

// Mappings (associative arrays)
mapping simple_map = ([ "key": "value" ]);
mapping complex_map = ([
    "int": 42,
    "string": "test",
    "array": ({ 1, 2, 3 })
    "nested": ([ "inner": "value" ])
]);

// Advanced types
status status_var = 1;
closure closure_var = #'write;
symbol symbol_var = 'test_symbol;
bytes bytes_var = "binary data";
struct test_struct *struct_var;
lwobject lwobject_var;
coroutine coroutine_var;
lpctype type_var;

// Quoted arrays (multisets)
mixed *multiset = (< "a", "b", "c" >);

// ============================================================================
// MODIFIERS AND QUALIFIERS
// ============================================================================

static int static_var = 10;
private int private_var = 20;
protected int protected_var = 30;
public int public_var = 40;
nomask void nomask_function() { }
varargs void varargs_function(int a, int b, int c) { }
deprecated void deprecated_function() { }
virtual inherit "/std/object";
nosave int nosave_var = 0;

// ============================================================================
// STRUCTS
// ============================================================================

struct point {
    int x;
    int y;
    int z;
};

struct player_data {
    string name;
    int level;
    int hp;
    int mp;
    mapping inventory;
    struct point *position;
};

#define COLOR_ME_WHEN_USED 1
int color_me_when_used = COLOR_ME_WHEN_USED;

// ============================================================================
// OPERATORS - All LPC operators
// ============================================================================

void test_operators() {
    int a = 10, b = 5, c;
    string s1 = "Hello", s2 = "World";
    mixed *arr = ({ 1, 2, 3 });

    // Arithmetic operators
    c = a + b;  // Addition
    c = a - b;  // Subtraction
    c = a * b;  // Multiplication
    c = a / b;  // Division
    c = a % b;  // Modulo

    // Comparison operators
    if (a == b) c = 1;  // Equal
    if (a != b) c = 1;  // Not equal
    if (a < b) c = 1;   // Less than
    if (a > b) c = 1;   // Greater than
    if (a <= b) c = 1;  // Less than or equal
    if (a >= b) c = 1;  // Greater than or equal

    // Logical operators
    if (a && b) c = 1;  // Logical AND
    if (a || b) c = 1;  // Logical OR
    if (!a) c = 1;  // Logical NOT

    // Bitwise operators
    c = a & b;  // Bitwise AND
    c = a | b;  // Bitwise OR
    c = a ^ b;  // Bitwise XOR
    c = ~a;     // Bitwise NOT
    c = a << 2;     // Left shift
    c = a >> 2;     // Right shift
    c = a >>> 2;    // Unsigned right shift

    // Assignment operators
    c = a;  // Simple assignment
    c += b;     // Add and assign
    c -= b;     // Subtract and assign
    c *= b;     // Multiply and assign
    c /= b;     // Divide and assign
    c %= b;     // Modulo and assign
    c &= b;     // Bitwise AND and assign
    c |= b;     // Bitwise OR and assign
    c ^= b;     // Bitwise XOR and assign
    c <<= 2;    // Left shift and assign
    c >>= 2;    // Right shift and assign
    c >>>= 2;   // Unsigned right shift and assign

    // Increment/Decrement
    c++;    // Post-increment
    ++c;    // Pre-increment
    c--;    // Post-decrement
    --c;    // Pre-decrement

    // String operators
    s1 = s2 + " LPC";   // Concatenation
    s1 = s2[0..4];  // Range extraction
    c = s1[0];  // Character access

    // Array operators
    arr = ({ 1 }) + ({ 2, 3 });     // Array concatenation
    arr -= ({ 2 });     // Array subtraction
    arr = arr[0..1];    // Array range
    arr = ({ 1, 2, 3 }) & ({ 2, 3, 4 });    // Array intersection

    // Ternary operator
    c = (a > b) ? a : b;    // Conditional

    // Range operator
    s1 = s2[0..5];  // String range
    arr = arr[1..<2];   // Array range with end offset

    // Comma operator
    c = (a = 5, b = 10, a + b);

    // Member access
    c = this_object()->query_level();

    // Index operator
    c = arr[0];
    s1 = simple_map["key"];
}

// ============================================================================
// CONTROL STRUCTURES
// ============================================================================

void test_control_structures() {
    int i, j;
    string name;
    mixed *items;

    // If-else
    if (i > 0) {
        write("Positive\n");
    } else if (i < 0) {
        write("Negative\n");
    } else {
        write("Zero\n");
    }

    // Brace-less if
    if (i > 0) {
        write("Positive\n");
    }

    // Switch-case (LDMUD cli=0 style)
    switch(i) {
    case 0:
        write("Zero\n");
        break;
    case 1:
    case 2:
    case 3:
        write("Small number\n");
        break;
    case 4..10:
        write("Medium number\n");
        break;
    default:
        write("Large number\n");
    }

    // While loop
    while (i < 10) {
        i++;
    }

    // Do-while loop
    do {
        i--;
    } while (i > 0);

    // For loop
    for (i = 0; i < 10; i++) {
        write(i + "\n");
    }

    // Foreach loop
    foreach (int value : ({ 1, 2, 3, 4, 5 })) {
        write(value + "\n");
    }

    // Foreach with index
    foreach (int value, int index : ({ 10, 20, 30 })) {
        write(sprintf("%d: %d\n", index, value));
    }

    // Foreach with mapping
    foreach (string key, mixed value : simple_map) {
        write(sprintf("%s => %O\n", key, value));
    }

    // Break and continue
    for (i = 0; i < 100; i++) {
        if (i % 2 == 0) {
            continue;
        }
        if (i > 50) {
            break;
        }
        write(i + "\n");
    }

    // Return
    if (i == 0) {
        return;
    }
}

// ============================================================================
// CLOSURES - Lambda expressions and function pointers
// ============================================================================

void test_closures() {
    closure simple_lambda;
    closure complex_lambda;
    closure func_pointer;
    mixed *arr;

    // Simple lambda with positional parameters
    simple_lambda = (: $1 + $2 :);
    write(funcall(simple_lambda, 5, 10) + "\n");

    // Lambda with expressions
    complex_lambda = (: $1 * 2 + $2 * 3 :);

    // Lambda with function calls
    simple_lambda = (: write($1 + "\n") :);

    // Function pointer (efun)
    func_pointer = #'write;

    // Function pointer (local function)
    func_pointer = #'test_operators;

    // Function pointer (object function)
    func_pointer = #'this_object()->query_name;

    // Symbol function
    func_pointer = symbol_function("test_function", this_object());

    // Unbound lambda
    closure unbound = unbound_lambda(
        ({'arg1, 'arg2}), ({
            #'+, 'arg1, 'arg2})
    );

    // Bind lambda to object
    closure bound = bind_lambda(#'query_name, this_player());

    // Using closures with map/filter
    arr = ({ 1, 2, 3, 4, 5 });
    arr = map(arr, (: $1 * 2 :));
    arr = filter(arr, (: $1 > 5 :));

    // Map with function pointer
    arr = map(({ "a", "b", "c" }), #'upper_case);

    // Lambda with multiple statements
    simple_lambda = lambda(
        ({'x}), ({
            #'?, ({
                #'>, 'x, 10}), ({
                #'write, "Large\n"}), ({
                #'write, "Small\n"})
        })
    );

    // Closure with captures
    int captured_var = 42;
    simple_lambda = (: $1 + captured_var :);
}

// ============================================================================
// EFUNS - Essential LPC functions (selection)
// ============================================================================

void test_efuns() {
    object ob;
    string str;
    mixed *arr;
    mapping map;
    int result;

    // Object functions
    ob = clone_object("/std/object");
    ob = load_object("/std/room");
    ob = find_object("/std/player");
    ob = present("sword", this_player());
    ob = environment(this_object());
    ob = first_inventory(this_object());
    ob = next_inventory(ob);
    ob = this_object();
    ob = this_player();
    ob = this_interactive();
    ob = previous_object();
    destruct(ob);

    // String functions
    str = sprintf("%s has %d gold", "Player", 100);
    str = capitalize("hello");
    str = lower_case("HELLO");
    str = upper_case("hello");
    result = strlen("test");
    arr = explode("one,two,three", ",");
    str = implode(({ "one", "two" }), ",");
    result = sscanf("Player has 100 gold", "%s has %d gold", str, result);
    str = replace_string("Hello World", "World", "LDMUD");

    // Array functions
    arr = allocate(10);
    arr = ({ 1, 2, 3 }) + ({ 4, 5 });
    result = sizeof(arr);
    arr = sort_array(({ 3, 1, 2 }), #'>);
    arr = unique_array(({ 1, 2, 2, 3 }), #'=);
    arr = filter(arr, (: $1 > 0 :));
    arr = map(arr, (: $1 * 2 :));
    result = member(({ 1, 2, 3 }), 2);

    // Mapping functions
    map = m_allocate(10);
    map = ([ "key": "value" ]);
    arr = m_indices(map);
    arr = m_values(map);
    result = sizeof(map);
    map = m_add(map, ([ "new": "entry" ]));
    map = m_delete(map, "key");
    result = m_contains(map, &str, "key");

    // Math functions
    result = abs(-5);
    result = max(10, 20);
    result = min(10, 20);
    result = random(100);
    float f = sin(3.14);
    f = cos(3.14);
    f = tan(3.14);
    f = sqrt(16.0);
    f = pow(2.0, 8.0);
    f = exp(1.0);
    f = log(10.0);

    // Time functions
    result = time();
    str = ctime(time());
    arr = localtime(time());
    arr = gmtime(time());
    arr = utime();

    // File I/O functions
    str = read_file("/path/to/file");
    result = write_file("/path/to/file", "content\n");
    result = file_size("/path/to/file");
    arr = get_dir("/path/to/dir");
    result = mkdir("/path/to/dir");
    result = rmdir("/path/to/dir");
    result = rm("/path/to/file");
    result = rename("/old", "/new");
    str = read_bytes("/file", 0, 100);
    result = write_bytes("/file", 0, "data");

    // Communication functions
    write("Hello\n");
    printf("%s has %d gold\n", "Player", 100);
    tell_object(this_player(), "Message\n");
    tell_room(environment(this_player()), "Room message\n");
    say("Everyone hears this\n");
    shout("Loud message\n");

    // Interactive functions
    ob = this_interactive();
    result = interactive(ob);
    input_to("callback_function");
    result = query_input_pending(ob);
    result = query_idle(ob);
    str = query_ip_name(ob);
    str = query_ip_number(ob);
    exec(ob, previous_object());

    // Call functions
    call_other(ob, "function_name", "arg");
    call_out("delayed_function", 10, "arg");
    result = find_call_out("delayed_function");
    remove_call_out(result);
    arr = call_out_info();

    // Security functions
    str = getuid(ob);
    str = geteuid(ob);
    seteuid("wizard");
    export_uid(ob);
    result = enable_commands();
    result = disable_commands();
    result = living(ob);
    set_living_name("player_name");

    // Debug functions
    debug_message("Debug output\n");
    mixed *trace = debug_info(DINFO_TRACE);
    result = query_verb();
    dump_driver_info(DINFO_DATA);
}

// ============================================================================
// DRIVER APPLY FUNCTIONS
// ============================================================================

void create() {
    // Called when object is created
    set_property("name", "Test Object");
}

void reset() {
    // Called periodically to reset object
    if (!query_property("initialized")) {
        set_property("initialized", 1);
    }
}

void init() {
    // Called when object enters an environment or player enters
    add_action("do_test", "test");
}

void heart_beat() {
    // Called periodically if set_heart_beat() is active
    static int counter = 0;
    counter++;
}

int clean_up(int flag) {
    // Called by master to clean up unused objects
    if (flag) {
        return 1;
    }
    return 0;
}

// ============================================================================
// CASTING
// ============================================================================

void test_casting() {
    mixed m = 42;
    int i;
    string s;
    object ob;

    // Cast to specific types
    i = ({int})m;
    s = ({string})m;
    ob = ({object})m;

    // Cast with arrays
    int *int_arr = ({int*})({ 1, 2, 3 });
    string *str_arr = ({string*})({ "a", "b" });

    // Type checking
    if (intp(m))
        write("It's an integer\n");
    if (stringp(m))
        write("It's a string\n");
    if (objectp(m))
        write("It's an object\n");
    if (pointerp(m))
        write("It's an array\n");
    if (mappingp(m))
        write("It's a mapping\n");
    if (closurep(m))
        write("It's a closure\n");
    if (symbolp(m))
        write("It's a symbol\n");
}

// ============================================================================
// ERROR HANDLING
// ============================================================================

void test_error_handling() {
    mixed error;
    int result;

    // Catch errors
    error = catch(result = 10 / 0);
    if (error) {
        write("Error caught: " + error + "\n");
    }

    // Catch with nolog
    error = catch(destruct(this_object()), nolog);

    // Throw error
    if (result < 0) {
        throw("Invalid result");
    }

    // Raise error (old style)
    if (result < 0) {
        raise_error("Invalid result\n");
    }
}

// ============================================================================
// INHERITANCE AND VIRTUAL OBJECTS
// ============================================================================

inherit "/std/object";
virtual inherit "/std/container";

// Override inherited function
nomask string query_name() {
    return ::query_name() + " [modified]";
}

// Call inherited version
void reset() {
    ::reset();
    // Additional reset code
}

// ============================================================================
// PREPROCESSOR FEATURES
// ============================================================================

#if 0
// Disabled code block
void disabled_function() {
    write("This won't compile\n");
}
#endif

#ifdef DEBUG
void debug_function() {
    write("Debug mode active\n");
}
#endif

#ifndef PRODUCTION
#define TEST_MODE 1
#endif

// Macro with parameters
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))

// String concatenation
#define MESSAGE "Hello " "World"

// Macro expansion
void test_macros() {
    int a = 10, b = 20;
    int max_value = MAX(a, b);
    write(MESSAGE + "\n");
}

// ============================================================================
// MULTI-LINE EXPRESSIONS AND ALIGNMENT
// ============================================================================

void test_alignment() {
    // Multi-line function call
    write(sprintf("This is a very long message with %s and %d and %f\n",
        "string parameter",
        42,
        3.14159));

    // Multi-line array
    int *numbers = ({
        1, 2, 3, 4, 5,
        6, 7, 8, 9, 10,
        11, 12, 13, 14, 15
    });

    // Multi-line mapping
    mapping config = ([
        "name": "Test Config",
        "version": "1.0",
        "enabled": 1,
        "settings": ([
            "debug": 1,
            "verbose": 0
        ])
    ]);

    // Multi-line conditional
    if (integer_var > 10
        && string_var == "test"
        && object_var != 0
        || float_var > 3.0) {
        write("Complex condition true\n");
    }

    // Chained method calls
    object_var->set_property("name", "value")
    ->set_property("level", 10)
    ->save_data();
}

// ============================================================================
// COMMENT FORMATTING TEST - Comments should NOT affect indentation
// ============================================================================

void test_comments_dont_leak_formatting() {
    int x = 1;

    // Test 1: Comment with unmatched opening brace {
    if (x > 0) {
        write("Should be indented 2 levels\n");
    }

    // Test 2: Comment with multiple braces {{ }} and parens ()
    if (x > 0) {
        write("Should be indented 2 levels\n");
    }

    // Test 3: Comment with unmatched closing brace }
    if (x > 0) {
        write("Should be indented 2 levels\n");
    }

    /* Test 4: Block comment with braces { } and parens () */
    if (x > 0) {
        write("Should be indented 2 levels\n");
    }

    /*
     * Test 5: Multi-line block comment
     * with braces { { { } } }
     * and parentheses ( ) ( )
     */
    if (x > 0) {
        write("Should be indented 2 levels\n");
    }

    if (x > 0) { // Comment with brace: if(y) { z = 1; }
        write("Should be indented 2 levels\n");
    }

    if (x > 0) { /* inline block { } */
        write("Should be indented 2 levels\n");
    }

    // Test 6: Comment with semicolon and brace: statement; }
    if (x > 0) {
        write("Should be indented 2 levels\n");
    }
}

// ============================================================================
// PRAGMAS AND COMPILER DIRECTIVES
// ============================================================================

#pragma strict_types
#pragma save_types
#pragma no_clone
#pragma no_inherit
#pragma no_shadow
#pragma resident
#pragma lightweight
#pragma range_check
#pragma rtt_checks
#pragma warn_missing_return
#pragma warn_deprecated
#pragma warn_empty_casts
#pragma pedantic

// ============================================================================
// SPECIAL SYNTAX PATTERNS
// ============================================================================

void test_special_syntax() {
    // Range operator in array
    int *arr = ({ 1, 2, 3, 4, 5 });
    int *slice = arr[1..3];     // Elements 1, 2, 3
    slice = arr[0..<2];     // All except last 2
    slice = arr[<3..<1];    // Last 3 to last 1

    // Range in switch
    switch(integer_var) {
    case 1..10:
        write("Between 1 and 10\n");
        break;
    case 11..20:
        write("Between 11 and 20\n");
        break;
    }

    // Reference parameters
    int ref_var;
    sscanf("test 123", "%s %d", string_var, &ref_var);
    m_contains(simple_map, &string_var, "key");

    // Spread operator (proposed)
    arr = ({ 1, 2, ({ 3, 4, 5 })... });
}

// ============================================================================
// COMMENTS
// ============================================================================

void test_comments() {
    // Single line comment

    /* Block comment */

    /*
     * Multi-line block comment
     * with multiple lines
     * of text
     */

    int x = 5;  // Inline comment

    /* Nested /* comments */ are not standard */

    // TODO: This is a todo comment
    // FIXME: This needs fixing
    // NOTE: Important note
    // HACK: Temporary solution

    if (str == "if(x){y}else{z}")
    { // No spaces added
        write("String comparison works\n");
    }
}

// ============================================================================
// COMPLEX NESTED STRUCTURES
// ============================================================================

void test_complex_nesting() {
    // Deeply nested data structure
    mapping complex = ([
        "users": ({
            ([ "name": "Alice", "level": 10 ]), ([
                "name": "Bob", "level": 20 ])
        }),
        "items": ({
            ([
                "name": "Sword",
                "stats": ([ "damage": 10, "speed": 5 ])
                "enchantments": ({ "fire", "ice" })
            ])
        })
    ]);

    // Nested closures
    closure outer = lambda(
        ({'x}), ({
            #'map, ({
                1, 2, 3}),
            lambda(
                ({'y}), ({
                    #'+, 'x, 'y})
            )
        })
    );

    // Complex filter/map chain
    mixed *result = map(
        filter(
            ({ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }),
            (: $1 % 2 == 0 :)
        ),
        (: $1 * 2 :)
    );
}

// ============================================================================
// TEST - String content should NOT be formatted
// ============================================================================

void test_strings_not_formatted() {
    string str;

    // Strings with closure-like content should NOT be modified
    str = "This is a closure: ({'arg1, 'arg2})";
    str = "Lambda: ({#'function, 'x, 'y})";
    str = "Array: ({ 1,2,3})";  // Spaces inside string should not be added
    str = "Cast: ({int})value";

    // Strings with switch/case should NOT be modified
    str = "switch(x) { case 1: break; }";
    str = "The switch statement";

    // Strings with operators should NOT be modified
    str = "x&&y||z";
    str = "value?true:false";
    str = "arr[0..5]";

    // Strings with comments should NOT be modified
    str = "/* this is not a comment */";
    str = "// this is not a comment";
    str = "value /* inline */ + 1";

    // Strings with braces should NOT be modified
    str = "function()  {  return  x;  }";   // Extra spaces preserved
    str = "if(x){y}else{z}";    // No spaces added

    // Complex strings with multiple formatters triggers
    write("unbound_lambda( ({'item, 'dest}), ({#'_move_hook_fun, 'item, 'dest}) )");
    write("switch(value){case 1:return({1,2,3});case 2:return({int})x;}");
    write("Closure: ({'x}) Lambda: ({#'func,'y}) Array: ({ 1, 2, 3})");

    // Multi-line strings should also be safe
    str = "This is a long string with " +
          "closure-like content: ({'arg}) and " +
          "array-like content: ({ 1,2,3}) that " +
          "should not be formatted at all";

    // String concatenation with formatting-sensitive content
    str = "function " + "test" + "()" + " {" + " return " + "({'x})" + "; }";

    // sprintf with format specifiers
    str = sprintf("Lambda: %O, Array: %O", ({'x}), ({ 1, 2, 3 }));
    write(sprintf("Switch: %s, Closure: %O", "switch(x)", ({#'func})));

    // Escaped quotes in strings
    str = "She said: \"Use ({'closure}) here\"";
    str = "Path: \"c:\\test\\({file})\\data\"";

    items = ({
        "room", "This appears to be a negotiation room of somekind",
        "furniture", "The furniture is new and most of it is made of wood",
        "desk", "There is a tidy pile of papers in the desk",
        "papers", "Papers seem to be forms of somekind",
        "armchair", "The armchair looks very expensive",
        "chairs", "One of the chairs doesn't look to as comfortable as the other one",
        "chair", "=chairs",
        "bookshelves", break_string("The books in these shelves are used by traders to 'store' "+
            "information about items that has been written down into their catalogs, making those "+
            "notes public to everyone. You may use 'list' and 'list <type>' to see what has "+
            "been stored and then 'lookup <name>' to read about it", 79)[0..<2],
        "shelves", "=bookshelves",
        "books", "=bookshelves",
        "book", "=bookshelves"
    });

    // Continue this string on the next line
    str = "\
Creator: " + channels[channel, CREATOR] + "\n\
Flags  : " + implode(channels[channel, FLAGS], ", ") + "\n\
Topic  : " + fix_string(channels[channel, TOPICS]) + "\n\
,-------------------------------------------------.\n\
| Listener       | Idle  | Listener       | Idle  |\n\
|-------------------------------------------------|\n";

}

// FINAL TEST - Real-world pattern
// ============================================================================

private mapping player_data = ([]);

int do_command(string arg) {
    object player = this_player();
    string *parts;
    int amount;

    if (!arg || arg == "") {
        return notify_fail("Usage: command <args>\n"), 0;
    }

    parts = explode(arg, " ");

    if (sizeof(parts) < 2) {
        return notify_fail("Need more arguments.\n"), 0;
    }

    switch(parts[0]) {
    case "set":
        if (sscanf(parts[1], "%d", amount) != 1) {
            return notify_fail("Invalid number.\n"), 0;
        }
        player_data[player] = amount;
        write("Set to " + amount + "\n");
        break;
    case "get":
        if (!m_contains(player_data, 0, player))
            return notify_fail("No data stored.\n"), 0;
        write("Value: " + player_data[player] + "\n");
        break;
    default:
        return notify_fail("Unknown command.\n"), 0;
    }

    return 1;
}

varargs mixed snoop(mixed snoopee)
{
    int result;

    if (snoopee && interactive(snoopee) && interactive_info(snoopee, II_SNOOP_NEXT)) {
        write("Busy.\n");
        return 0;
    }
    result = snoopee ? efun::snoop(this_player(), snoopee)
                     : efun::snoop(this_player());
    switch (result) {
    case -1:
        write("Busy.\n");
        break;
    case 0:
        write("Failed.\n");
        break;
    case 1:
        write("Ok.\n");
        break;
    }
    if (result > 0) return snoopee;

    return 0;
}

varargs void add_worth(int value, object ob)
{
    mixed old;
#ifdef __COMPAT_MODE__
    switch (explode(object_name(previous_object()), "/")[0]) {
#else
    switch (explode(object_name(previous_object()), "/")[1]) {
#endif
    default:
        raise_error("Illegal call of add_worth.\n");
    case "obj":
    case "std":
    case "room":
    }
    if (!ob) {
        if (!(ob = previous_object(1)))
            return;
    }
    if (intp(old = get_extra_wizinfo(ob)))
        set_extra_wizinfo(ob, old + value);
}

void inaugurate_master(int arg)

// Perform mudlib specific setup of the master.
//
// Argument:
//   arg: 0 if the mud just started.
//        1 if the master is reactivated destructed one.
//        2 if the master is a reactivated destructed one, which lost all
//             variables.
//        3 if the master was just reloaded.
//
// This function is called whenever the master becomes fully operational
// after (re)loading (it is now recognized as _the_ master).
// This doesn't imply that the game is up and running.
//
// This function has at least to set up the driverhooks to use. Also, any
// mudwho or wizlist handling has to be initialized here.
//
// Besides that, do whatever you feel you need to do,
// e.g. set_driver_hook(), or give the master a decent euid.

{
    if (!arg) {
        if (previous_object() && previous_object() != this_object()) {
            return;
        }
        set_extra_wizinfo(0, allocate(BACKBONE_WIZINFO_SIZE));
    }

    mudwho_init(arg);

    // Wizlist simulation
    if (find_call_out("wiz_decay") < 0)
        call_out("wiz_decay", 3600);

    set_driver_hook(
        H_MOVE_OBJECT0,
        unbound_lambda(({'item, 'dest}), ({
            #'_move_hook_fun, 'item, 'dest})
        )
    );
    set_driver_hook(
        H_LOAD_UIDS,
        unbound_lambda(({'object_name}), ({
            #'_load_uids_fun, 'object_name, ({#'previous_object})})
        )
    );
    set_driver_hook(
        H_CLONE_UIDS,
        unbound_lambda(({ /* object */ 'blueprint, 'new_name}), ({
            #'_clone_uids_fun, 'blueprint, 'new_name, ({#'previous_object})})
        )
    );
    /*
     * We simulate the old compat mode behavior and call reset()
     * with an argument (0 when creating, 1 when resetting).
     * 
     * Non-compat mudlibs usually specify "create" for the H_CREATE_* hooks
     * and "reset" for the H_RESET hook.
     */
    set_driver_hook(H_CREATE_SUPER,
        unbound_lambda(({'ob}),
            ({#'_create_fun, 'ob, ({#'this_object})})
        )
    );
    set_driver_hook(
        H_CREATE_OB,
        unbound_lambda(({'ob}), ({
            #'_create_fun, 'ob, ({#'this_object})})
        )
    );
    set_driver_hook(
        H_CREATE_CLONE,
        unbound_lambda(({'ob}), ({
            #'_create_fun, 'ob, ({#'this_object})})
        )
    );
    set_driver_hook(
        H_RESET,
        unbound_lambda(0, ({
            #'funcall, ({#'symbol_function, "reset", ({#'this_object})}), 1})
        )
    );
    set_driver_hook(H_CLEAN_UP, "clean_up");
    set_driver_hook(H_MODIFY_COMMAND, ([
        "e":"east", "w":"west", "s":"south", "n":"north",
        "d":"down", "u":"up", "nw":"northwest", "ne":"northeast",
        "sw":"southwest", "se":"southeast" ]));
    set_driver_hook(H_MODIFY_COMMAND_FNAME, "modify_command");
    set_driver_hook(H_NOTIFY_FAIL, "What?\n");
    set_driver_hook(H_INCLUDE_DIRS, #'_include_dirs_hook);
    set_driver_hook(H_AUTO_INCLUDE, #'_auto_include_hook);
}


//---------------------------------------------------------------------------
void save_wiz_file()

/*
 * Save the wizlist file.
 */

{
#ifdef __WIZLIST__
    rm(__WIZLIST__);
    write_file(
        __WIZLIST__,
        implode(
            map(wizlist_info(),
                lambda(({'a}),
                    ({#'sprintf, "%s %d %d\n",
                        ({#'[, 'a, WL_NAME}),
                        ({#'[, 'a, WL_COMMANDS}),
                        ({#'[, 'a, WL_EXTRA})
                    })
                )
            ), ""
        )
    );
#endif
}

// Test file for macro highlighting

#define MY_MACRO 42
#define __DEBUG__ 1
#define BUFFER_SIZE 1024

void test_macros() {
    int value = MY_MACRO;
    string file = __WIZLIST__;
    int size = BUFFER_SIZE;

    // Hook constants
    set_driver_hook(H_MOVE_OBJECT0, "move_hook");
    set_driver_hook(H_LOAD_UIDS, "load_uids");

    // Wizlist fields
    int commands = WL_COMMANDS;
    string name = WL_NAME;
    int extra = WL_EXTRA;

    // Version check
    if (__LDMUD__) {
        write("Running LDMUD\n");
    }

    // Debug mode
    if (__DEBUG__) {
        debug_message("Debug mode enabled");
    }
}

query_racial_damage_aptness(string arg)
{
    if(arg && member(racial_damage_aptness, arg + "_aptness")) { return racial_damage_aptness[arg + "_aptness"]; }
    if(arg && member(racial_damage_aptness, arg)) { return racial_damage_aptness[arg]; }

    if(!arg) return racial_damage_aptness;
}

add_racial_damage_aptness(string type, int amount)
{
    if(!type || !amount) { return; }
    if(member(racial_damage_aptness, type)) { racial_damage_aptness[type] += amount; }
    else if(member(racial_damage_aptness, type + "_aptness")) { racial_damage_aptness[type + "_aptness"] += amount; }
    else { racial_damage_aptness += ([ type: amount, ]); }
}

// ============================================================================
// LAMBDA/CLOSURE FORMATTER TESTS - Critical test cases for brace balance
// ============================================================================

void test_lambda_brace_balance_simple() {
    closure simple;

    // Simple nested lambda - ensure no extra braces added
    simple = lambda(
        ({'x}), ({
            #'?, ({
                #'>, 'x, 10}), ({
                #'write, "Large\n"})
        })
    );
}

void test_lambda_brace_balance_complex() {
    // Complex nested lambda from lib/living.c - the original failing case
    // This should have exactly 3 closing braces before ));
    filter_array(all_inventory(environment()) - ({ this_object() }),
        lambda(({'a}),
            ({#'?,
                ({#'living,'a}),
                ({#'?!,
                    ({#'call_other,'a, "test_dark", 1}),
                    ({#'?,
                        ({#'call_other, 'a, "query_see_invis", 1}),
                        ({#'call_other, 'a, "receive",
                            cap_name, level, "movement", msg})})})})
        ));
}

void test_lambda_multiple_nested() {
    // Triple nested closure with multiple branches
    closure complex = lambda(
        ({'a, 'b}), ({
            #'?, ({
                #'>, 'a, 'b}), ({
                #'?, ({
                    #'>, 'a, 100}), ({
                    #'write, "Very large"}), ({
                    #'write, "Large"})}), ({
                #'write, "Small"})
        })
    );
}

void test_function_references() {
    closure ref;

    // Function references should be preserved exactly
    ref = #'write;
    ref = #'living;
    ref = #'call_other;
    ref = #'query_name;

    // Operator references
    ref = #'?;
    ref = #'?!;
    ref = #'||;
    ref = #'&&;
    ref = #'+;
    ref = #'-;
    ref = #'*;
    ref = #'/;
    ref = #'%;
    ref = #'>;
    ref = #'<;
    ref = #'>=;
    ref = #'<=;
    ref = #'==;
    ref = #'!=;
    ref = #'[;
}

void test_quoted_symbols() {
    // Quoted symbols in closures
    closure c1 = lambda(({'x, 'y, 'z}), ({#'+, 'x, 'y, 'z}));

    // Single quoted symbol
    closure c2 = lambda(({'item}), ({#'call_other, 'item, "query_weight"}));

    // Multiple operations with quoted symbols
    closure c3 = lambda(
        ({'a, 'b}), ({
            #'*, ({#'+, 'a, 'b}), ({#'-, 'a, 'b})})
    );
}

void test_unbound_lambda_variations() {
    closure unbound;

    // Simple unbound lambda
    unbound = unbound_lambda(
        ({'arg1, 'arg2}), ({
            #'+, 'arg1, 'arg2})
    );

    // Unbound lambda with nested operations
    unbound = unbound_lambda(
        ({'item, 'dest}), ({
            #'call_other, 'item, "move", 'dest})
    );

    // Complex unbound lambda with conditionals
    unbound = unbound_lambda(
        ({'ob}), ({
            #'?, ({
                #'living, 'ob}), ({
                #'call_other, 'ob, "query_hp"}), ({
                0})
        })
    );
}

void test_filter_map_with_closures() {
    mixed *arr = ({ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });
    object *obs;

    // Filter with complex lambda
    arr = filter(arr, lambda(({'x}), ({#'>, 'x, 5})));

    // Map with nested operations
    arr = map(arr, lambda(({'x}), ({#'*, 'x, 2})));

    // Filter with conditional logic
    arr = filter(arr, lambda(
        ({'x}), ({
            #'?, ({
                #'>, 'x, 10}), ({
                #'?, ({
                    #'<, 'x, 20}), ({
                    1}), ({
                    0})}), ({
                0})
        })
    ));

    // Map on objects with function references
    obs = filter(all_inventory(this_object()),
        lambda(({'a}), ({#'living, 'a})));
}

void test_mixed_data_and_closure_arrays() {
    mixed *data_array = ({ 1, 2, 3, 4, 5 });
    closure c;

    // Regular data array - should have spaces
    data_array = ({ "one", "two", "three" });
    data_array = ({ 1, 2, 3 }) + ({ 4, 5, 6 });

    // Closure arrays - should have no spaces
    c = lambda(({'x}), ({#'+, 'x, 1}));

    // Mixed in same expression
    data_array = ({ 1, 2, 3 }) + filter(({ 4, 5, 6 }),
        lambda(({'x}), ({#'>, 'x, 4})));
}

void test_lambda_with_strings() {
    closure c;

    // Lambda with string arguments
    c = lambda(
        ({'name}), ({
            #'write, ({#'+, "Hello, ", 'name, "\n"})})
    );

    // Lambda with multiple string operations
    c = lambda(
        ({'msg, 'target}), ({
            #'call_other, 'target, "receive", ({#'+, "You hear: ", 'msg})})
    );
}

void test_deeply_nested_closures() {
    // Four levels of nesting
    closure deep = lambda(
        ({'a}), ({
            #'?, ({
                #'>, 'a, 0}), ({
                #'?, ({
                    #'>, 'a, 10}), ({
                    #'?, ({
                        #'>, 'a, 100}), ({
                        #'write, "Huge"}), ({
                        #'write, "Large"})}), ({
                    #'write, "Medium"})}), ({
                #'write, "Small"})
        })
    );
}

void test_closure_array_in_function_call() {
    // Closure as direct argument
    set_heart_beat(lambda(0, ({#'heart_beat})));

    // Multiple closures as arguments
    call_out(lambda(0, ({#'delayed_action, "test"})), 5);

    // Nested function calls with closures
    write(sprintf("%O\n",
        map(({ 1, 2, 3 }),
            lambda(({'x}), ({#'*, 'x, 'x})))));
}

void test_sprintf_with_closures() {
    // Lambda using sprintf inside
    closure format = lambda(
        ({'a}), ({
            #'sprintf, "%s %d %d\n",
            ({#'[, 'a, 0}),
            ({#'[, 'a, 1}),
            ({#'[, 'a, 2})})
    );
}

void test_real_world_pattern_from_living() {
    // Exact pattern that was failing in lib/living.c line 374
    filter_array(all_inventory(environment()) - ({ this_object() }),
        lambda(({'a}),
            ({#'?,
                ({#'living, 'a}),
                ({#'?!,
                    ({#'call_other, 'a, "test_dark", 1}),
                    ({#'?,
                        ({#'call_other, 'a, "query_see_invis", 1}),
                        ({#'call_other, 'a, "receive",
                            cap_name, level, "movement", msg})})})})
        ));
}

void test_edge_case_empty_closures() {
    closure empty;

    // Empty closure body
    empty = lambda(({'x}), ({#'noop}));

    // Closure returning constant
    empty = lambda(({'x}), ({0}));
    empty = lambda(({'x}), ({1}));
}

void test_closure_with_array_operations() {
    closure arr_op;

    // Array indexing in closure
    arr_op = lambda(
        ({'arr, 'idx}), ({
            #'[, 'arr, 'idx})
    );

    // Array range in closure
    arr_op = lambda(
        ({'arr}), ({
            #'[.., 'arr, 0, 5})
    );
}

void test_closure_with_array_operations() {
    closure arr_op;

    // Array indexing in closure
    arr_op = lambda(
        ({'arr, 'idx}), ({
            #'[, 'arr, 'idx})
    );

    // Array range in closure
    arr_op = lambda(
        ({'arr}), ({
            #'[.., 'arr, 0, 5})
    );

    // Real-world nested lambda (4 levels) from lib/living.c
    if (query_level() >= 3) {
        arr = filter_array(arr,
            lambda(({'x}), ({#'!=,
                ({#'filter_array, 'x, lambda(({'a}),
                    ({#'&&, ({#'environment, 'a}),
                        ({#'==, ({#'query_cap_name, ({#'environment, 'a})}),
                            cap_name, level, "movement", msg }) }) )}) }) ));
    } else {
        arr = filter_array(arr,
            lambda(({'x}),({#'!=,
                ({#'filter_array, 'x, lambda(({'a}),
                    ({#'&&, ({#'environment, 'a}),
                        ({#'==, ({#'query_cap_name, ({#'environment, 'a})}),
                            cap_name, level, "movement", msg }) }) )}) }) ));
    }
}

int preserve_closing() {
    int evasion;
    int evasion2 = 200;     // example value
    int max_weight, weight_penalty;

    ///    dodge_chance -= local_weight/4;
    max_weight = this_object()->query_max_weight();
    // If max_weight<1, object is most likely ghost or bugged,
    if (max_weight < 1)
        return 0;

    evasion = min( ({ 100, evasion2 }) );
    evasion2 = min(({ 100, evasion }));

    weight_penalty = round(local_weight * 100.0 / max_weight);
    weight_penalty -= round(weight_penalty * evasion / 150.0);  // 66% reduction to weight penalty with max evasion
    if(weight_penalty > 95) { weight_penalty = 95; }
    if(weight_penalty < 0) { weight_penalty = 0; }

    if(sizeof(filter_array(all_inventory(), lambda(({ 'a }),
        ({#'call_other, 'a, "query_worn"}) ) ) ) )
        quit_yes_no();
    else
        start_quit();
    return 1;
}

void test_inline_specials() {
    this_object()->set_class(min(({ changed_class, 45 })));
    this_object()->set_class(max (({ changed_class, 45 })));

    string s = ::short(arg);
    s = regreplace(s, " \\([12]h\\)", " <*" + weapon_color + "*>", 0);
    return s;
}

private int foreign_arts_check() {
    if(!wielded_by) return 0;

    if(wielded_by->query_useskill() && member(ACCEPTED_SKILLS, lower_case(wielded_by->query_useskill()->query_skill_name()) == -1))     // Using a skill not in the list
        return random(100) > 50;

    if(wielded_by->query_castspell() && member(ACCEPTED_SPELLS, lower_case(wielded_by->query_castspell()->query_spell_name()) == -1))   // Using a seill not in the list
        return random(100) > 50;
}

